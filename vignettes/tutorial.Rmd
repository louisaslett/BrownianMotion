---
title: "Tutorial for BrownianMotion package"
output:
  rmarkdown::html_vignette:
    fig_width: 7
    fig_height: 4
    toc: true
bibliography: refs.bib
vignette: >
  %\VignetteIndexEntry{Tutorial for BrownianMotion package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

First load the package and the `magrittr` utility package, which provides the `%>%` pipe operator, allowing natural chaining of commands.  We also set the seed to ensure reproducibility of this vignette.

```{r setup}
library(BrownianMotion)
library(magrittr)
set.seed(212)
```

The first task is to create an object which will contain the Brownian motion path and layer information.  This is acomplished using the `create_bm()` function.  It is possible to call with all default options, but here for demonstration purposes we will force the path to start at $W_1 = 100$ (the default is $W_0 = 0$).

```{r}
bm <- create.bm(1, 100)
```

# Standard simulation

## Unconditional simulation

The simplest operation is unconditional simulation of the path at future times (beyond the existing path).  Although one could call the specialised function `sim.uncond()`, this is not necessary: there is a universal function, `sim()`, which automatically detects the correct kind of simulation to perform based on the current path and new times requested.  Thus, specifying a vector of times $t>t_0$ to `sim()` will result in unconditional simulation:

```{r}
bm %>% sim(2:4)
```

Note in the above:

- we provide a vector of times, $t = (2,3,4)$ here, and these will be simulated in order forwards to ensure unconditional simulation sequentially;
- the `bm` object is updated in place ... there is no need to assign the result back to bm (ie you do *not* need to do `bm <- bm %>% sim(2:4)`).

At this point we can see a plot of our nascent path:

```{r}
plot(bm)
```

Here, black dots represent path observations and these are connected by grey lines.  Note grey lines do *not* represent the actual path, although see later section on [Publication Graphics](#publication-graphics) for details on plotting an illustrative sample path.

## Brownian bridge simulation

The simplest step beyond unconditional simulation would be to simulate times which are intermediate to already observed time points, achieved using Brownian bridge simulation.  As before, although one could call the specialised function `sim.bb()`, this is not necessary as `sim()` will identify when points fall at a time requiring conditioning.  Note, these can be mixed with additional unconditioned times, for example:

```{r}
bm %>% sim(c(1.5, 2.5, 3.5, 4.5))
plot(bm)
```

results in conditional simulation of $t=(1.5, 2.5, 3.5)$ and an extension of the path unconditionally to $t=4.5$.

In particular, note that the first argument to sim can be a vector of times produced in any manner, say via `seq()` or even by random simulation of times:

```{r}
bm %>% sim(runif(5, 1, 4.5))
plot(bm)
```

This will simulate at 5 times randomly chosen between the start and end times.  Note this highlights that the vector of times passed to `sim()` need not be sorted: (non-standard) sorting of required times is handled by the package to ensure robustness of functionals.

## A peek under the hood

At this point it is instructive to look at the stored path:

- `$t` contains the times of observations, $t$;
- `$W_t` contains the value of the path at those times, $W_t$.

For ease of reading, the following example takes these two slots of the Brownian motion object and places them in a data frame, though this is not necessary:

```{r}
data.frame(t   = bm$t,
           W_t = bm$W_t)
```

In this simple setting $t$ and $W_t$ comprise the *"path skeleton"*: they are a finite dimensional representation of the Brownian motion path, which can be used to reconstruct the path at any other time point of interest. 

As an illustration of using this "under the hood" information, we can simulate an Exponential($\lambda = W_{4.5} / 10$) time past the end of the path, without having had to track in our code that $t=4.5$ is the end of the path what this current end time is:

```{r}
bm %>% sim(max(bm$t)+rexp(1, bm$W_t[which.max(bm$t)]/10))
plot(bm)
```

# Layers, layers, everywhere!

In many settings we want to simulate Brownian motion together with *"layer"* information. Layer information determines a compact (spatial) interval which constrains the path over a given time interval. This can be achieved using this package in three broad ways:

- *Bessel*: This follows (broadly) the approach outlined in [@MCAP].
- *Localised*: This follows (broadly) the approach outlined in [@DEV], following the implementation in [@SCALE]
- *Intersection*: This follows (broadly) the approach outlined in [@BERN], 

There are merits to using each of these approaches, and so the user has the flexibility (when possible) of specifying these.

If a layer is simulated then this forms part of the *path skeleton*. Once a layer is simulated, then simulating further points of the path is more involved: again, these fall into the category of unconditional and conditional simulation. 

## Bessel

We begin by specifying that we want to simulate a Bessel layer over the interval $t=[6,8]$. Note that $t=6$ is beyond the existing terminal time of the path, and so the path will first be (unconditionally) simulated to this time: 

```{r}
bm %>% bessel.layers(6, 8)
plot(bm)
```

Purple is used to illustrate a Bessel layer (which will be useful later when we consider simultaneously different layer types). The solid lines are the *layer* indicating the spatial interval which constrains the path (the path falls entirely between the upper and lower solid lines). The dashed lines indicate a spatial interval which *does not* constrain the path (the path at some point will fall out-with the interval). As the end-points of the interval co-incide with the dashed lines we further know that the path *will* fall at some point both above the upper dashed line *and* below the lower dashed line.

Note we can now simulate at a time falling within this Bessel layer specification and the above constraints will be honoured and result in an updated layer specification.  This is achieved using either the specialised `sim.condbessel()` function, or (recommended) the same `sim()` function used to date. It will automatically detect the surrounding layer information and conduct conditional Bessel layer simulation.  For example, simulating at $t=7$ gives:

```{r}
bm %>% sim(7)
plot(bm)
```

In particular, note that the Bessel layer specification has now updated, resulting in the single layer becoming two Bessel layers either side of the newly simulated time.  In this case (though not always) this has resulted in two further variants of the Bessel layer. This is shown in the left hand interval by *two dotted* lines replacing the interior dashed lines of the earlier figure, and in the right hand interval by *one dotted, one dashed* lines replacing the interior dashed lines.

The dotted line indicates a more nuanced layer information, where the layer does not coincide with the end-points for the interval, but again indicates a spatial interval which *does not* constrain the path (the path at some point fall out-with the interval). 

More precisely, in the left hand interval with *two dotted* lines there are three possible cases for the (unrealised) path. In particular, either: 

1. the path has a minimum which falls between the lower dotted and lower solid line, **and**, a maximum which falls between the upper dotted and upper solid line; or
1. the path has a minimum which falls between the lower dotted and lower solid line, **and**, a maximum which falls between the maximum of the end-points of the path and the upper dotted line; or
1. the path has a minimum which falls between the minimum of the end-points of the path and the lower dotted line, **and**, a maximum which falls between the upper dotted and upper solid line. 

The right hand interval has both a dashed (lower) and dotted (upper) line. These follow the same convention as the two earlier examples. As one of the end-points co-incides with the dashed line (lower) we know the path at some point falls below this level. This eliminates the possibility of case 3 in the list above, leaving case 1 and 2. It is possible that the dashed and dotted lines were in the reverse order (dashed being the upper, and dotted being the lower), in which case we would either have case 1 or 3. 

When using `bessel.layers()` there is no need for the start and end times to co-incide with the current skeleton. It can be some future interval (as above), an interval of time pre-ceding the current skeleton, or an interval which partially includes the current skeleton. If there are pre-existing layers then a call to `bessel.layers()` only introduces layers for intervals which do not already have layers. For instance, consider the introduction of layers over the interval $t\in[5,9]$:

```{r}
bm %>% bessel.layers(5,9)
plot(bm)
```

Note that as the `bm` object becomes larger, calling the `plot` command can be less informative. You may instead wish to only `plot` a specific time interval for clarity. This is possible using the `t.lim` argument within the `plot` command. For instance, suppose you were interested only in visualising the interval $[5,7.5]$: 

```{r}
plot(bm, t.lim = c(5,7.5))
```

## Localised

### First passage times

The second layer type we will consider is based around first passage times of Brownian motion.

First passage times are the basis of the "localised layers" we introduce fully in the next subsection.  Here, we consider the path initialiased at its current terminal value, and determine the first time it leaves a prescribed interval. The interval can be prescribed by the user in a number of different ways, by specifying among a choice of arguments:

- `delta`: specifying a symmetric interval around the current terminal value;
- `delta.l` and `delta.u`: specifying a asymmetric interval which is `delta.l` below and `delta.u` above the current terminal value;
- `l` and `u`: specifying the lower and upper boundary values directly.

To better illustrate this we begin by simulating the existing path unconditionally at time $t=10$ by again calling `sim()` before then simulating a first passage to a symmetric interval $\pm 1$ from $W_{10}$.  Notice that commands can be chained together using the pipe `%>%` operator:

```{r}
bm %>%
  sim(10) %>%
  first.passage(delta = 1)
plot(bm)
```

The green lines indicate the bounds specified by You, the user. The green line does not form part of the realised Brownian motion, and is used for visualisation. As such, it can be turned off using the `hide.user` argument in the plot command:  

```{r}
plot(bm, hide.user = TRUE)
```

Note that the green lines were over-plotting solid red lines. Again, solid lines form part of the Brownian motion object and indicate the interval which constrains the path over the specified interval. We term this a *"localised layer"* as the end-point coincides with layer. Red is used as the colour to plot such layer types. The dashed lines follow the earlier convention, although note there will only be one. In the case above we in effect have the upper dashed line coinciding with the left hand end-point, and both the dashed and solid lines coinciding with the right hand end-point.

If we instead we want asymmetric layers and use the arguments `delta.l` and `delta.u` then these are the lower and upper offsets (respectively) of the current terminal end-point:

```{r}
bm %>% first.passage(delta.l = -1, delta.u=3)
plot(bm)
```

The output in this case is slightly different as this is achieved algorithmically by decomposing the requested layers into iterative calls of the *symmetric* variant of the function.

We may not be interested in the first passage time of a level offset by the current terminal time, but instead some specified level. This can be achieved by using the arguments `l` and `u` where these are the lower and upper layers requested. For instance, we may want the first passage time of the (spatial) interval $[90,100]$: 

```{r}
bm %>% first.passage(l = 90, u=100)
plot(bm)
```

Note that if using the arguments `l` and `u` then the current terminal point must be contained within the interval, as otherwise it is not possible and results in an error: 

```{r,error=TRUE,purl=FALSE}
bm %>% first.passage(l = 80, u=85)
```

Time points within a localised layer may be simulated using the specialised function `sim.condlocal()`, or (recommended) by using `sim()` which will automatically detect the surrounding layer information to perform the correct conditioning.

```{r}
bm %>% sim(c(17, 18))
plot(bm)
```

Note conditional simulations within a localised layer can give rise to a change in layer type, in this instance resulting in the first part of the localised layer becoming of Bessel type (recalling that for localised layers the layer coincides with the the end-point).

### Localised layer over a specified interval

Simulating localised layers by means first passage times can be advantageous in some settings, although the time the first passage occurs is random, and this randomness can introduce its own complications. 

Instead, we may wish to simulate localised layers over a specified interval (in the same manner as we did for Bessel layers). For instance, suppose we want a localised layer in the interval $t\in[23,29]$ this can be achieved using the `localised.layers()` function: 

```{r}
bm %>% localise.layers(23,29)
plot(bm)
```

Note that the resulting skeleton for the interval will comprise zero or more (red) localised layers, followed by a single (purple) Bessel layer: this because the end-point will no longer coincide with the layer. By default `delta` is chosen to be $\sqrt{t-s}/2$, although this can be altered by the user using the argument `mult` which multiplies the default layer size. For instance, 

```{r}
bm %>% localise.layers(31,35,mult=1.5)
plot(bm)
```

Intermediary points can be added in the same way as before. For instance, using our recommended `sim()` function: 

```{r}
bm %>% sim(33)
plot(bm)
```

We may wish to add a bridge analogue of a localised layer: ie a localised layer over one or more existing intervals in the skeleton. This can be achieved again by using the `localise.layers()` function. For instance, we may wish to intrduce localised intervals over every interval between times $[10,40]$ (where $40$ exceeds the current end-time of $35$):


```{r}
bm %>% localise.layers(10,40)
plot(bm)
```

Note that the path has been extended (unconditionally) beyond $t=35$ as per above. For each interval within the current skeleton, which did not already have a layer, a localised layer has been introduced. The "bridge" localised layers are simulated by means of an appropriate scaling of unconditional Brownian motions, and so have a gradient of $(W_t-W_s)/(t-s)$. The interior dashed, dotted and solid lines, together with the associated Bessel layer all follow the earlier conventions (albeit now with a gradient). The outer horizontal solid lines are for the use of You (and don't form part of the skeleton) to easily indicate a spatial interval which constrains the path over a given (time) interval. We can again more clearly see the localised bridge layers by specifying a shorter interval to plot the path (for instance $[27,33]$): 

```{r}
plot(bm, t.lim=c(27,33))
```

As the horizontal layers do not strictly form part of the path skeleton, these can be toggled off when plotting by again using the `hide.user` argument: 

```{r}
plot(bm, t.lim=c(27,33), hide.user = TRUE)
```

### (Another) peek under the hood

In addition to the earlier discussion on the slots `$t` and `$W_t`, there are slots which contain the layering information, both for the main path and those in the transformed space just discussed above.

- `$layers` is a data frame containing the layering information of the main path, including variables:
    - `type` to indicate the layer type, one of:
        - `bessel`
        - `localised`
        - `intersection` (see forthcoming section);
        - `bessel-bb`
        - `localised-bb`
        - `intersection-bb` (see forthcoming section);
      
      The suffix `-bb` indicates that this layer type results from simulating the localised layer bridge of the last section.
    - `t.l` and `t.u` giving the temporal interval (left and right time points) to which the layer applies;
    - `Ld` corresponds to the lower solid line;
    - `Uu` corresponds to the upper solid line;
    - `Lu` corresponds to the lower interior dashed/dotted line;
    - `Ud` corresponds to the upper interior dashed/dotted line;
    - `Lu.hard` indicating whether the lower interior line coincides with the end point;
    - `Ud.hard` indicating whether the upper interior line coincides with the end point;
- `$user.layers` is a data frame containing the information on which first passage layers were requested by You (resulting in the green lines on the plot).  This contains
    - `t.l` and `t.u` giving the temporal interval (left and right time points) to which the layer applies;
    - `L` and `U` which are the boundaries specified by You (perhaps indirectly via `delta` or `delta.l`/`delta.u`)
- `$bb.local` is a nested Brownian motion object used in the construction of the localised layer bridges.  Note this will only contain intervals pertaining to the localised layer bridge intervals of `$layers` (those ending `-bb`), but otherwise follows the same form.

For example, the path produced to date in this vignette has the following internal layering representation:

```{r,eval=FALSE}
bm$layers
```
```{r,echo=FALSE}
rmarkdown::paged_table(bm$layers)
```

```{r,eval=FALSE}
bm$user.layers
```
```{r,echo=FALSE,results='asis'}
knitr::kable(bm$user.layers)
```

```{r,eval=FALSE}
bm$bb.local$layers
```
```{r,echo=FALSE,results='asis'}
knitr::kable(bm$bb.local$layers)
```


## Intersection 

Now suppose we want an Intersection layer over the interval $t=[50,60]$, this can be done by calling the function `intersection.layers()`. The structure of introducing Intersection layers follows that of Bessel layers. Note that $t=50$ is beyond the current terminal point of the path: 

```{r}
bm %>% intersection.layers(50,60)
plot(bm)
```

Blue is used to illustrate an Intersection layer. Again, solid lines are the *layer* indicating the spatial interval which constrains the path. The interior lines for Intersection layers are always dashed. Dashed lines have the same interpretation as for Bessel layers, but need not coincide with the end-points for an interval. More precisely, we know the path has a maximum which falls between the upper dashed and solid lines, and a minimum which falls between the lower dashed and solid lines.  

Intermediary points of the trajectory can be either simulated using the dedicated function `sim.condintersection()`, or (recommended) one can simply again use the `sim()` function. For instance, consider simulating the path at $t=11$: 

```{r}
bm %>% sim(55)
plot(bm)
```

Note that on simulating an intermediary point(s) a number of Bessel (purple) or Intersection layers may arise. Intersection layers have the same interpretation as the parent Intersection layer, and Bessel layers are the same as in the earlier section. By default, the package will if possible attempt to "convert" Intersection layers to Bessel layers: we will address this default in the next subsection. Any further simulation will be handled appropriately for the given layer type by using the `sim()` function. 

### (Yet Another) peek under the hood

As demonstrated in the previous section, by default the package has a preference for using Bessel layers over Intersection layers wherever possible. It is typical that the user will want to only consider one layer type, and the Bessel layer type has been selected as default as this is most likely to be the one practitioners will use. We do however want the flexibility to use multiple layer types or change the default to Intersection. 

To do this we can change the default argument from `prefer = "bessel"` to `prefer = "intersection"` within the functions we have considered. For instance, we may consider a new path (`bm2`) initialised at $W_0=0$:

```{r}
set.seed(42)
bm2 <- create.bm(prefer = "intersection")
```

This has the consequence that any call to `sim()` (with no further argument as the preference is inherited from the creation of the path) will where possible convert Bessel layers to Intersection layers. Note that although it is only occasionally possible to convert Intersection layers to Bessel layers, it is always possible to change Bessel layers to Intersection layers. 

For instance, suppose we simulate Bessel layers over $t\in[1,3]$: 

```{r}
bm2 %>% bessel.layers(1, 3)
plot(bm2)
```

then if we want to simulate the path at $t=2$ and have resultant Bessel layers then this needs to be specified by the user as it differs from the default on the paths creation (`prefer = "intersection"`):

```{r}
bm2 %>% sim(2, prefer = "bessel")
plot(bm2)
```

In particular, further simulation of the path at $t=1.25$ and $t=2.5$ results in both Bessel layers (in the interval $[1,2]$ and $[2,3]$ being converted to Intersection layers: 

```{r}
bm2 %>% sim(c(1.25,2.5))
plot(bm2)
```

Note that we do not need to specify we have a preference for Intersection layers, as this preference is an attribute assigned to the path on its creation using `create.bm()`. In principle this could be changed for the path globally (for instance, `bm2$prefer <- "bessel"`), but this is not necessary as we will outline below.

It is not possible to convert from or to Localised layers from other layer types. However, once the path has been created with the attribute `prefer="intersection"` then conditional simulation of localised layers will result in the appearance of Intersection layers (as opposed to Bessel layers). For instance, note that when simulating a Localised layer over the interval $t\in[4,5]$ that the final interval is an Intersection layer (and not a Bessel layer as before): 

```{r}
bm2 %>% localise.layers(4,5)
plot(bm2)
```

The preference for Intersection layers inherited from the creation of the path can be changed when calling any of the other functions we have introduce. For instance, consider simulating localised layers (of the Bessel sort) in the interval $t\in[6,8]$: 

```{r}
bm2 %>% localise.layers(6,8,prefer="bessel")
plot(bm2)
```

and then the simulation of intermediary points in this interval: 

```{r}
bm2 %>% sim(c(6.5,7,7.5),prefer="bessel")
plot(bm2)
```

We can change the layer type (if possible) for every interval in the path by simply calling either `bessel.layers()` or `intersection.layers()` together with arguments for the end-points fo the path. For instance, suppose we now wanted Intersection layers: 

```{r}
bm2 %>% intersection.layers(0,8)
plot(bm2)
```

results in any Bessel layers being converted to Intersection layers. Similarly we could attempt to convert back to Bessel layers (although this may not always be possible for every interval): 

```{r}
bm2 %>% bessel.layers(0,8)
plot(bm2)
```

Note that converting the layers from Intersection to Bessel or Bessel to Intersection does not change the preference when calling the `sim()` function. For instance: 

```{r}
bm2 %>% sim(3.75)
plot(bm2)
```

# Refinement

When simulating layers the package will by default control the size of the layer so it scales appropriately with the length of the interval being considered. In particular, by default, the package will attempt to ensure the difference between the upper solid and upper dashed/dotted lines *AND* the difference between the lower solid and upper dashed/dotted lines is no greater than $\sqrt{t-s}$ (where $s$ and $t$ are the left and right hand end-points of the interval respectively). This control on the layer size can be removed by changing the `refine=TRUE` attribute to `refine=FALSE` on creation of the path. Note that this is not recommended as it can introduce numerical instability, but to show its affect consider the following Bessel layer over the interval $[0,10]$: 

```{r}
set.seed(42^2)
bm3 <- create.bm(refine = FALSE)
bm3 %>% bessel.layers(0, 10)
plot(bm3)
```

Now, if we simulate a number of intermediary points (say a grid of $20$), then note that although we again have Bessel layers that the size of the Bessel layers is "stretched" when contrasted with earlier simulations: 

```{r}
bm3 %>% sim(seq(0,10,by=0.5))
plot(bm3)
```

Contrast this with a similar path where we haven't set `refine=FALSE`:

```{r}
bm4 <- create.bm()
bm4 %>% bessel.layers(0, 10)
bm4 %>% sim(seq(0,10,by=0.5))
plot(bm4)
```

Whether the package does refinement by default is inherited from the attribute when the path is created. We can either change this at some future point globally (for instance, `bm3$refine <- TRUE`), or alternatively specify within the other functionals in the same manner as the `prefer` attribute discussed earlier. For instance, consider the introduction of mid-points to the existing path in the interval $[0,5]$:

```{r}
bm3 %>% sim(seq(0,5,by=0.25),refine = TRUE)
plot(bm3)
```

Note that the intervals in the first half of the path have been refined, but the second half of the path remains the same.

Now, in the case where we *are* refining by default (`refine = TRUE`), then we may want to alter the default layer size. This is done using the `mult` attribute, which was described earlier with Localised layers. Recall that by default when refining, the difference between the upper solid and upper dashed/dotted lines *AND* the difference between the lower solid and upper dashed/dotted lines is no greater than $\sqrt{t-s}$. The `mult` attribute multiplies this tolerance by a user-specified amount. By default, `mult = 1` and is specified at the creation of the path. For instance, consider a new path (`bm5`) together with Bessel layers in the interval $[0,10]$, but with the default layer size multiplied by $3$ :

```{r}
bm5 <- create.bm(mult=3)
bm5 %>% bessel.layers(0, 10)
plot(bm5)
```

The simulation of the path at additional points will inherit `mult=3`. For instance, contrast the following with `bm4` above: 

```{r}
bm5 %>% sim(seq(0,10,by=0.5))
plot(bm5)
```

If we introduce an additional points (say mid-points to the existing path in the interval $[0,5]$), but we want increased increased refinement (say of `mult=1`) this can be done by changing the default argument in any of the earlier functions as before. For instance: 

```{r}
bm5 %>% sim(seq(0,5,by=0.25),mult = 1)
plot(bm5)
```

Note that the intervals in the first half of the path are far more resolved. It is possible to set the layer size to some constant level (not dependent on the length of the interval) by specifying `mult` to be at a level the reciprocal of $\sqrt{t-s}$. This however is not recommended, as it can introduce numerical instability. 

Finally, we may wish to refine the existing intervals without the introduction of additional points. This can be achieved using the `refine` function, which can *increase* the resolution on any (or all) intervals. For instance:

```{r}
bm5 %>% refine(5,10,mult = 1)
plot(bm5)
```

The `mult = 1` argument has increased the resolution of existing layers in the interval $[5,10]$ by $3\times$, and will be comparable to the first half of the path.

# Deletion

It is possible that You want to delete both the path observations and layers, or only the layers, of the skeleton over some specified interval. This can be achieved within the package by using the `delete.skeleton` command, and specifying an open interval which you wish to delete from the skeleton. The left and right hand ends of the open interval are specified using the arguments `l` and `r` respectively. For instance, considering `bm5`, we may wish to delete the entire skeleton in the interval $(2.5,5)$: 

```{r}
bm5 %>% delete.skeleton(l = 2.5, r = 5)
plot(bm5)
```
By default the package will delete both path observations and layers within the open interval (by default the argument `type  = "all"`). However, deletion of only the layers (retaining the path observations) is possible by setting `type = "layer"`. For instance, considering deleting only the skeleton layers in the interval $(5,7.5)$:

```{r}
bm5 %>% delete.skeleton(l = 5, r = 7.5, type = "layer")
plot(bm5)
```

Note that as a safety precaution, `l` and `r` *must* co-incide with time points within the skeleton. As a consequence, if You want to delete an interval which does not co-incide with time points within the skeleton then You must first introduce those points using the `sim` function. For instance, consider deleting the skeleton entirely in the interval $(2.0001,7.9999)$ (noting these times do not currently appear in the skeleton) then this can be achieved as follows: 

```{r}
bm5 %>% sim(c(2.0001,7.9999)) %>% delete.skeleton(l = 2.0001, r = 7.9999)
plot(bm5)
```

In some scenarios we may wish to delete the path entirely to the left or right of some point. This is possible by not specifying the right or left point (respectively). For instance, suppose we wish to delete the skeleton entirely to the right of $t=2$ then: 

```{r}
bm5 %>% delete.skeleton(l = 2)
plot(bm5)
```

Alternatively, deletion entirely to the left of $t=1$ is possible in a similar manner by not specifying the `l` argument: 

```{r}
bm5 %>% delete.skeleton(r = 1)
plot(bm5)
```

Note that (as a fail-safe) it is not possible to delete the entire path by leaving *both* arguments un-specified. Intead You should do this by removing the `bm5` object from your workspace using the base R `rm` command. If you attempt to do this You will get an (informative) error: 

```{r,error=TRUE,purl=FALSE}
bm5 %>% delete.skeleton()
```

# Publication Graphics

# References


